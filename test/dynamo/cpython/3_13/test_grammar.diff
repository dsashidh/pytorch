diff --git a/test/dynamo/cpython/3_13/test_grammar.py b/test/dynamo/cpython/3_13/test_grammar.py
index 4f1fc2e86fd..a092c4cecd6 100644
--- a/test/dynamo/cpython/3_13/test_grammar.py
+++ b/test/dynamo/cpython/3_13/test_grammar.py
@@ -1,3 +1,58 @@
+# ======= BEGIN Dynamo patch =======
+# Owner(s): ["module: dynamo"]
+
+# ruff: noqa
+# flake8: noqa
+
+import sys
+import torch
+import torch._dynamo.test_case
+import unittest
+from torch._dynamo.test_case import CPythonTestCase
+from torch.testing._internal.common_utils import (
+    run_tests,
+    xfailIfTorchDynamo,
+)
+
+
+__TestCase = CPythonTestCase
+
+
+# redirect import statements
+import sys
+import importlib.abc
+
+redirect_imports = (
+    "test.mapping_tests",
+    "test.typinganndata",
+    "test.test_grammar",
+    "test.test_math",
+    "test.test_iter",
+    "test.typinganndata.ann_module",
+)
+
+class RedirectImportFinder(importlib.abc.MetaPathFinder):
+    def find_spec(self, fullname, path, target=None):
+        # Check if the import is the problematic one
+        if fullname in redirect_imports:
+            try:
+                # Attempt to import the standalone module
+                name = fullname.removeprefix("test.")
+                r = importlib.import_module(name)
+                # Redirect the module in sys.modules
+                sys.modules[fullname] = r
+                # Return a module spec from the found module
+                return importlib.util.find_spec(name)
+            except ImportError:
+                return None
+        return None
+
+# Add the custom finder to sys.meta_path
+sys.meta_path.insert(0, RedirectImportFinder())
+
+
+# ======= END DYNAMO PATCH =======
+
 # Python test set -- part 1, grammar.
 # This just tests whether the parser accepts them all.
 
@@ -16,12 +71,90 @@ import test.typinganndata.ann_module as ann_module
 import typing
 from test.typinganndata import ann_module2
 import test
-from test.support.numbers import (
-    VALID_UNDERSCORE_LITERALS,
-    INVALID_UNDERSCORE_LITERALS,
-)
 
-class TokenTests(unittest.TestCase):
+# These are shared with test_tokenize and other test modules.
+#
+# Note: since several test cases filter out floats by looking for "e" and ".",
+# don't add hexadecimal literals that contain "e" or "E".
+VALID_UNDERSCORE_LITERALS = [
+    '0_0_0',
+    '4_2',
+    '1_0000_0000',
+    '0b1001_0100',
+    '0xffff_ffff',
+    '0o5_7_7',
+    '1_00_00.5',
+    '1_00_00.5e5',
+    '1_00_00e5_1',
+    '1e1_0',
+    '.1_4',
+    '.1_4e1',
+    '0b_0',
+    '0x_f',
+    '0o_5',
+    '1_00_00j',
+    '1_00_00.5j',
+    '1_00_00e5_1j',
+    '.1_4j',
+    '(1_2.5+3_3j)',
+    '(.5_6j)',
+]
+INVALID_UNDERSCORE_LITERALS = [
+    # Trailing underscores:
+    '0_',
+    '42_',
+    '1.4j_',
+    '0x_',
+    '0b1_',
+    '0xf_',
+    '0o5_',
+    '0 if 1_Else 1',
+    # Underscores in the base selector:
+    '0_b0',
+    '0_xf',
+    '0_o5',
+    # Old-style octal, still disallowed:
+    '0_7',
+    '09_99',
+    # Multiple consecutive underscores:
+    '4_______2',
+    '0.1__4',
+    '0.1__4j',
+    '0b1001__0100',
+    '0xffff__ffff',
+    '0x___',
+    '0o5__77',
+    '1e1__0',
+    '1e1__0j',
+    # Underscore right before a dot:
+    '1_.4',
+    '1_.4j',
+    # Underscore right after a dot:
+    '1._4',
+    '1._4j',
+    '._5',
+    '._5j',
+    # Underscore right after a sign:
+    '1.0e+_1',
+    '1.0e+_1j',
+    # Underscore right before j:
+    '1.4_j',
+    '1.4e5_j',
+    # Underscore right before e:
+    '1_e1',
+    '1.4_e1',
+    '1.4_e1j',
+    # Underscore right after e:
+    '1e_1',
+    '1.4e_1',
+    '1.4e_1j',
+    # Complex cases with parens:
+    '(1+1.5_j_)',
+    '(1+1.5_j)',
+]
+
+
+class TokenTests(__TestCase):
 
     from test.support import check_syntax_error
     from test.support.warnings_helper import check_syntax_warning
@@ -239,7 +372,7 @@ class CNS:
         return self._dct[item]
 
 
-class GrammarTests(unittest.TestCase):
+class GrammarTests(__TestCase):
 
     from test.support import check_syntax_error
     from test.support.warnings_helper import check_syntax_warning
@@ -323,13 +456,6 @@ class GrammarTests(unittest.TestCase):
             print(x)
         with self.assertRaises(UnboundLocalError):
             fbad()
-        def f2bad():
-            (no_such_global): int
-            print(no_such_global)
-        try:
-            f2bad()
-        except Exception as e:
-            self.assertIs(type(e), NameError)
 
         # class semantics
         class C:
@@ -1333,30 +1459,6 @@ class GrammarTests(unittest.TestCase):
             compile("try:\n    pass\nexcept Exception as a.b:\n    pass", "?", "exec")
             compile("try:\n    pass\nexcept Exception as a[b]:\n    pass", "?", "exec")
 
-    def test_try_star(self):
-        ### try_stmt: 'try': suite (except_star_clause : suite) + ['else' ':' suite]
-        ### except_star_clause: 'except*' expr ['as' NAME]
-        try:
-            1/0
-        except* ZeroDivisionError:
-            pass
-        else:
-            pass
-        try: 1/0
-        except* EOFError: pass
-        except* ZeroDivisionError as msg: pass
-        else: pass
-        try: 1/0
-        except* (EOFError, TypeError, ZeroDivisionError): pass
-        try: 1/0
-        except* (EOFError, TypeError, ZeroDivisionError) as msg: pass
-        try: pass
-        finally: pass
-        with self.assertRaises(SyntaxError):
-            compile("try:\n    pass\nexcept* Exception as a.b:\n    pass", "?", "exec")
-            compile("try:\n    pass\nexcept* Exception as a[b]:\n    pass", "?", "exec")
-            compile("try:\n    pass\nexcept*:\n    pass", "?", "exec")
-
     def test_suite(self):
         # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT
         if 1: pass
@@ -1952,18 +2054,6 @@ class GrammarTests(unittest.TestCase):
         with self.assertRaises(Done):
             foo().send(None)
 
-    def test_complex_lambda(self):
-        def test1(foo, bar):
-            return ""
-
-        def test2():
-            return f"{test1(
-                foo=lambda: '、、、、、、、、、、、、、、、、、',
-                bar=lambda: 'abcdefghijklmnopqrstuvwxyz 123456789 123456789',
-            )}"
-
-        self.assertEqual(test2(), "")
-
 
-if __name__ == '__main__':
-    unittest.main()
+if __name__ == "__main__":
+    run_tests()
